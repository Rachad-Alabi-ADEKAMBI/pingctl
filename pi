#!/usr/bin/env sh
########################################################################################################################
#
# This tool is used for several Ping Identity related products including:
#
#   - Managing Ping Identity PingOne environment.
#   - Managing Ping Identity DevOps environment for Docker and Kubernetes.
#   - Managing Hashicorp Vault Secrets
#
# ------------
# Installation
# ------------
#   brew install pi
#   brew upgrade pi
#
# ------------
# Requirements
# ------------
# The script requires the following tools to be installed:
JQ="jq"
BASE64="base64"
OPENSSL="openssl"
KUBECTL="kubectl"
KUBECTX="kubectx"
KUBENS="kubens"
ENVSUBST="envsubst"
DOCKER="docker"
CURL="curl -sL "
VAULT="vault"
# Optional tools
JWT="jwt"
#
# In addition, the assumption is that kubectl is configured to authenticate and apply manifests to the Kubernetes
# cluster. For EKS clusters, this requires an AWS key and secret with the appropriate IAM policies to be configured and
# requires that the aws CLI tool and probably the aws-iam-authenticator CLI tool are installed.
########################################################################################################################

CWD=$(pwd)
# shellcheck disable=SC2164
# cd "$( dirname "${0}" )"
#THIS="$( basename "${0}" )"
#THIS_DIR=`pwd`

PI_CMD="pi"

STANDARD_VARIABLES="
  PING_IDENTITY_DEVOPS_USER
  PING_IDENTITY_DEVOPS_KEY
  PING_IDENTITY_DEVOPS_HOME
  PING_IDENTITY_DEVOPS_REGISTRY
  PING_IDENTITY_DEVOPS_TAG
  PING_IDENTITY_ACCEPT_EULA
  VAULT_ADDR
  VAULT_CACERT
  VAULT_SECRET_PREFIX
  PINGONE_ENVIRONMENT_ID
  PINGONE_WORKER_APP_CLIENT_ID
  PINGONE_WORKER_APP_CLIENT_SECRET"

################################################################################
# Version Info
################################################################################
VERSION="1.0.0"

################################################################################
# Ping Identity tools & config information
################################################################################
DOT_PINGIDENTITY="${HOME}/.pingidentity"
CONFIG_FILE="${DOT_PINGIDENTITY}/config"
PRINT_CONFIG_FILE="${HOME}/.pingidentity/config"
PI_WORK_DIR="${DOT_PINGIDENTITY}/${PI_CMD}"
test -d "${PI_WORK_DIR}" || mkdir -p "${PI_WORK_DIR}"
KUBE_OIDC_CACHE="${HOME}/.kube/cache/oidc-login"

################################################################################
# Get Current Kubenetes Info
################################################################################
CURRENT_K8S_CONTEXT="$(kubectl config current-context 2> /dev/null)"
CURRENT_K8S_NAMESPACE="$(kubectl config view --minify --output 'jsonpath={..namespace}' 2> /dev/null)"

################################################################################
# Check for a .pingidentity directory with propertyfile
################################################################################
test -d "${DOT_PINGIDENTITY}" || mkdir -p "${DOT_PINGIDENTITY}"

################################################################################
# Source devops file
################################################################################
# shellcheck disable=SC1090
test -f "${CONFIG_FILE}" && . "${CONFIG_FILE}"

# Temporary directory used throughout script and cleaned up at exit
TMP_DIR="$(mktemp -d)"
PINGONE_POST_JSON="${TMP_DIR}/pingone-post.json"
PINGONE_CALL_RESPONSE="${TMP_DIR}/pingone-call-response.json"
PINGONE_DEBUG="${TMP_DIR}/pingone.debug"

################################################################################
# cleanup - Ensures that we cleanup any temporary directories we create upon exit
################################################################################
cleanup ()
{
  rm -rf "$TMP_DIR"
}

trap cleanup EXIT

################################################################################
# Terminal codes for echoing of RED or GREEN colors, and back to NORMAL
################################################################################
if test "${PI_COLORIZE}" == "on"; then
  RED='\033[0;31m'
  GREEN='\033[0;32m'
  NORMAL='\033[0m'
  BOLD='\033[1m'
else
  RED=
  GREEN=
  NORMAL=
  BOLD=
fi

################################################################################
# echo_red - Echo message in red color
################################################################################
echo_red()
{
    echo "${RED}$*${NORMAL}"
}

################################################################################
# echo_green - Echo message in green color
################################################################################
echo_green()
{
    echo "${GREEN}$*${NORMAL}"
}

################################################################################
# echo_error (message) - Echo's an Error: message
################################################################################
echo_error()
{
    if test  ! -z "$*"; then
      echo "-------------------------------------------------------------------------"
	    echo_red "Error: ${1}"
      echo "-------------------------------------------------------------------------"
    fi
}

banner()
{
  echo "-------------------------------------------------------------------------"
  echo "$*"
  echo "-------------------------------------------------------------------------"

}

run_command()
{
  CMD="${1}"
  CMD_OUTPUT="${2}"

  banner "Command: ${BOLD}$CMD $(test ! -z "${CMD_OUTPUT}" && echo "> ${CMD_OUTPUT}")${NORMAL}"

  test -z "${CMD_OUTPUT}" && $CMD
  test ! -z "${CMD_OUTPUT}" && $CMD > "${CMD_OUTPUT}"
}


################################################################################
# check_config_file - Verify that the config_file is found
################################################################################
check_config_file()
{
  test ! -f "${CONFIG_FILE}" \
    && echo_red "No ${PI_CMD} config found.  Please run:\n" \
    && echo "  ${PI_CMD} config" \
    && exit
}

################################################################################
# check_variables - Verify that certain variables are set
################################################################################
check_variables()
{
  for _var in "${@}"; do
    test -z "$(get_value "${_var}")" \
      && echo_red "Variable is not set: ${_var}" \
      && _var_check_fails=true
  done

  test ${_var_check_fails} \
    && echo \
    && echo "To get more information on these variables:" \
    && echo_green "  https://pi-cli.pingidentity.com/" \
    && echo \
    && echo "Set this/these in your config with:" \
    && echo_green "  ${PI_CMD} config" \
    && echo \
    && exit
}


################################################################################
USAGE_HEADER="pi is a CLI from Ping Identity to manage PingOne, PingDevOps and other projects/tools."

################################################################################
USAGE_KUBERNETES_DETAIL="Kubernetes Tools

Usage:
  ${PI_CMD} k8s generate             # Kubernetes Resource Generation Tools
  ${PI_CMD} k8s oidc                 # kubectl/kubelogin OIDC Tools"

################################################################################
USAGE_GENERATE_DETAIL="Kubernetes Resource Generation Tools

Usage:
  ${PI_CMD} k8s generate devops-secret                    # Ping DevOps secret
  ${PI_CMD} k8s generate tls-secret {domain}              # TLS Cert/Key (i.e. example.com)
  ${PI_CMD} k8s generate ssh-id-secret {ssh id_rsa file}  # SSH ID Key (i.e. ~/.ssh/id_rsa)
  ${PI_CMD} k8s generate license {product} {ver}          # Eval license file for product/ver
  ${PI_CMD} k8s generate license-secret {license file}    # License secret from license file
  ${PI_CMD} k8s generate license-secret {product} {ver}   # License secret for product/ver"

################################################################################
USAGE_OIDC_DETAIL="kubectl/kubelogin OIDC Tools

Usage:
  ${PI_CMD} k8s oidc clear                                # Remove ~/.kube/cache/oidc-login
  ${PI_CMD} k8s oidc {claim}                              # Get oidc claim (i.e. email, groups)
  ${PI_CMD} k8s oidc info                                 # Display jwt"

################################################################################
USAGE_PINGONE_DETAIL="Manage PingOne Evironments

Usage:
  ${PI_CMD} pingone list                 # List objects
  ${PI_CMD} pingone get                  # Get object

  ${PI_CMD} pingone add                  # Add object
  ${PI_CMD} pingone delete               # Delete object

  ${PI_CMD} pingone add-user-group       # Add group to user
  ${PI_CMD} pingone delete-user-group    # Delete group from user

  ${PI_CMD} pingone token                # Obtain access token"

################################################################################
USAGE_PINGONE_LIST_DETAIL="List PingOne Objects

Usage:
  ${PI_CMD} pingone list groups           # List groups
  ${PI_CMD} pingone list populations      # List all populations
  ${PI_CMD} pingone list users            # List users

Flags:
  -o [ table | csv | json ]        # Output format (default: table)
  -r                               # Print REST Calls"

################################################################################
USAGE_PINGONE_GET_DETAIL="Get PingOne Objects

Usage:
  ${PI_CMD} pingone get group        {name}     # Get group by name
  ${PI_CMD} pingone get population   {name}     # Get population by name
  ${PI_CMD} pingone get user         {name}     # Get user by name

Flags:
  -o [ table | csv | json ]        # Output format (default: table)
  -r                               # Print REST Calls"

################################################################################
USAGE_PINGONE_ADD_DETAIL="Add PingOne Objects

Usage:
  ${PI_CMD} pingone add group {group name}                     # Add group

  ${PI_CMD} pingone add population {population name}           # Add population


  ${PI_CMD} pingone add user {username} {first} {last} [email] # Add user
     # REQUIRED: username, first last
     # OPTIONAL: email (username if not provided)


Flags:
  -p {population name}             # Population to place user/group into
                                   # If not proivded 'Default' population used
  -r                               # Print REST Calls"

################################################################################
USAGE_PINGONE_DELETE_DETAIL="Delete PingOne Objects

Usage:
  ${PI_CMD} pingone delete group       {name}    # Delete group
  ${PI_CMD} pingone delete population  {name}    # Delete population
  ${PI_CMD} pingone delete user        {name}    # Delete user

Flags:
  -r                               # Print REST Calls"

################################################################################
USAGE_PINGONE_ADD_USER_GROUP_DETAIL="Add PingOne Group to User

Usage:
  ${PI_CMD} pingone add-user-group {username} {groupname}  # Add group to user"

################################################################################

USAGE_PINGONE_DELETE_USER_GROUP_DETAIL="Delete PingOne Group from User
  ${PI_CMD} pingone delete-user-group {username} {groupname}  # Delete group from user"

################################################################################
USAGE_VAULT="Hashicorp Vault Tools

Usage:
  ${PI_CMD} vault get-token                   # Get vault token for cli commands
  ${PI_CMD} vault create-annotations {secret} # Create kubernetes annotaions for secret"

################################################################################
# usage - Print any message sent as an error and then the usage information
################################################################################
usage()
{
  echo_error "$*"

  echo "$USAGE_HEADER

Usage:
  ${PI_CMD} [command] [flags]

Available Commands:
  info            Print pi config
  config          Manage pi config
  version         Version Details and Check
  clean           Remove ~/.pingidentity/${PI_CMD}

  kubernetes      Kubernetes Tools
  pingone         PineOne Tools
  vault           Hashicorp Vault Tools

Flags:
  -h              Help for pi

${GREEN}Further help:${NORMAL}
  https://pi-cmd.pingidentity.com"

  exit
}

################################################################################
# usage_command - print usage info for a specific command
################################################################################
usage_command()
{
  _usageCmd="${1}" && shift

  test -z "${_usageCmd}" && _usageCmd="${USAGE_CONTEXT}"
  test -z "${_usageCmd}" && usage

  echo_error "${*}"

  echo "$(get_value "${_usageCmd}")"

  echo
  exit
  case "${_usageCmd}" in
    pingone)
      echo "${USAGE_PINGONE_DETAIL}"
      ;;
    pingone-list)
      echo "${USAGE_PINGONE_LIST_DETAIL}"
      ;;
    pingone-get)
      echo "$(get_value _usageCmd)"
      ;;
    generate)
      echo "${USAGE_GENERATE_DETAIL}"
      ;;
    vault)
      echo "${USAGE_VAULT}"
      ;;
    *)
      usage
      ;;
  esac

  echo
  exit
}

################################################################################
# check_for_tool (tool_name)
#
# Using which command, validate that the tool_name is found
################################################################################
check_for_tool()
{
  _tool="${1}"
  which "${_tool}" >/dev/null

  test $? -eq 1 && echo_error "'${_tool}' not found, but required to perform function. Please install" && exit
}

################################################################################
# get_value (variable)
#
# Get the value of a vaiable, preserving the spaces
################################################################################
get_value ()
{
  if test ! -z "${1}"; then
    IFS="%%"
    eval printf '%s' "\${${1}}"
    unset IFS
  fi
}

################################################################################
# get_value (variable)
#
# Get the value of a vaiable, preserving the spaces
################################################################################
find_setup_arg_value()
{
  _valToFind="${1}"
  _findFile="${2}"
  _defaultVal="${3}"

  _valFound=$(grep "$_valToFind" "${_findFile}" | sed "s/.*$_valToFind \(.*\) .*\\\\$/\1/g")

  test -z "${_valFound}" && _valFound="${_defaultVal}"

  echo "${_valFound}"
}

################################################################################
# add_bash_aliases ()
#
# Ensure that the bash_alias file is a part of .bash_profile
################################################################################
add_bash_aliases()
{


    PI_BASH_PROFILE="/usr/local/etc/bash_profile.${PI_CMD}"
    BASH_PROFILE="${HOME}/.bash_profile"

    # Touch the .bash_profile incase it's not setup yet
    touch "${BASH_PROFILE}"

    grep "${PI_BASH_PROFILE}" "${BASH_PROFILE}" > /dev/null

    if test "${?}" = "1"; then
        echo "
################################################################################
#                         Ping Identity Alias Files
################################################################################

Let's add helper alias' and functions to your shell.
We are assuming you use bash and will add these to your ${BASH_PROFILE}
"

        echo "  OK if we add a 'source ${PI_BASH_PROFILE}' command to your ${BASH_PROFILE} (y/n) [y] ? \c"
        read -r answer

        if [ "${answer}" = "" ] || [ "${answer}" = "Y" ] || [ "${answer}" = "y" ]; then
            echo "
# Ping Identity Aliases - Added with '${PI_CMD} config' on $(date)
test -f '${PI_BASH_PROFILE}' && source '${PI_BASH_PROFILE}'" >> "${BASH_PROFILE}"
        fi
    fi

    grep "sourcePingIdentityFiles" "${BASH_PROFILE}" >/dev/null

    if test "$?" = "1"; then
        echo "  OK if we add a 'sourcePingIdentityFiles' command to your ${BASH_PROFILE} (y/n) [y] ? \c"
        read -r answer
        if [ "${answer}" = "" ] || [ "${answer}" = "Y" ] || [ "${answer}" = "y" ]; then
            echo "
# Source PingIdentity Files Alias - Added with '${PI_CMD} config' on $(date)
sourcePingIdentityFiles" >> "${BASH_PROFILE}"
        fi
    fi
}

################################################################################
# get_custom_variables ()
#
# Obtain a list of custom variablees
################################################################################
get_custom_variables()
{
    grep -v "^#" "${CONFIG_FILE}" | \
    while read -r _line
    do
        test -z "${_line}" && continue
        _name="${_line%%=*}"

        echo "${STANDARD_VARIABLES}" | grep "${_name}" >/dev/null
        _grepRC=$?

        if test ${_grepRC} -ne 0; then
            echo "${_name}"
        fi
    done
}

################################################################################
# add_config (file, variable, default, prompt)
#
# Add a config variale to the devops file, using the prompt sent, and defaulting
# if no value is provided.
################################################################################
add_config()
{
  PROPS_FILE="${1}" && shift
  VAR_TO_SET="${1}" && shift
  VAR_DEFAULT="${1}" && shift
  VAR_PROMPT="${*}"

  CURRENT_VALUE=$(get_value "${VAR_TO_SET}")
  test -z "${CURRENT_VALUE}" && CURRENT_VALUE="${VAR_DEFAULT}"

  echo "${VAR_PROMPT}"
  echo "    [${GREEN}${CURRENT_VALUE}${NORMAL}] ? \c"
  read -r answer
  echo

  if test ! -z "${answer}"; then
    if test "${answer}" = "-"; then
      if test -z "${VAR_TO_SET}"; then
        echo >> "${PROPS_FILE}"
      else
        eval "unset \${VAR_TO_SET}"

        # If the variable being uset, is a standard variable, then echo an
        # empty value in the property file, otherwise, lose it from new
        # property file
        echo "${STANDARD_VARIABLES}" | grep "${VAR_TO_SET}" >/dev/null

        test $? -eq 0 && echo "${VAR_TO_SET}=" >> "${PROPS_FILE}"
      fi
    else
      if test -z "${VAR_TO_SET}"; then
        echo "${answer}" >> "${PROPS_FILE}"
      else
        eval "export \${VAR_TO_SET}=${answer}"
        echo "${VAR_TO_SET}=${answer}" >> "${PROPS_FILE}"
      fi
    fi
  else
    if test -z "${VAR_TO_SET}"; then
        echo "${CURRENT_VALUE}" >> "${PROPS_FILE}"
    else
        echo "${VAR_TO_SET}=${CURRENT_VALUE}" >> "${PROPS_FILE}"
    fi
  fi
}

################################################################################
################################################################################
print_variable_setting_instructions()
{
  echo "
################################################################################
#  Setting Variables:
#      [enter]     to accept current value
#      [-]         to unset the value
#      new value   to change value
################################################################################
  "
}

################################################################################
# add_config_customize (file)
#
# Add a config variale to the devops file, using the prompt sent, and defaulting
# if no value is provided.
################################################################################
add_config_custom()
{
  PROPS_FILE="${1}" && shift
  _custom_variables="${*}"

  test ! -z "${_custom_variables}" && print_variable_setting_instructions

  for _varName in ${_custom_variables}; do
      add_config "${PROPS_FILE}" "${_varName}"  ""  "Set Custom Variable '${_varName}'"
  done

  echo "
################################################################################
#  Add Additional Variables:
#
#      [enter]     to end adding additional variables
#      NAME=VALUE  to add that variable with setting (i.e. VERBOSE=true)
################################################################################
  "

  while true
  do
      echo "Enter a new NAME=VALUE [enter to end] : \c"

      read -r answer

      test -z "${answer}" && break

      echo "$answer" >> "${PROPS_FILE}"
  done
}

################################################################################
# devops_add_comment (file, comment)
#
# Add a comment to the devops file
################################################################################
devops_add_comment()
{
  _TFILE="${1}" && shift
  _MSG="${*}"

  echo "${_MSG}"
  echo "${_MSG}" >> "${_TFILE}"
}

echo_info_variable()
{
  _varToEcho="${1}"

  printf "  %-30s : %s\n" "${_varToEcho}" "$(get_value "${_varToEcho}")"
}

################################################################################
# pi_info ()
#
# Prints all the variables of the ~/.pingidentity/devops file
################################################################################
pi_info()
{
    _show="${1}"

    test "${_show}" != "-v" && PINGONE_WORKER_APP_CLIENT_SECRET="*** REDACTED *** (use -v to display)"
    test "${_show}" != "-v" && PING_IDENTITY_DEVOPS_KEY="*** REDACTED *** (use -v to display)"

    echo "
################################################################################
#     Ping Identity Information (version $VERSION)
################################################################################
#     PingOne variables sourced from ${PRINT_CONFIG_FILE}
################################################################################
"
    echo_info_variable PINGONE_ENVIRONMENT_ID
    echo_info_variable PINGONE_WORKER_APP_CLIENT_ID
    echo_info_variable PINGONE_WORKER_APP_CLIENT_SECRET
    echo

echo "################################################################################
#     DevOps variables sourced from ${PRINT_CONFIG_FILE}
################################################################################
"

    echo_info_variable PING_IDENTITY_DEVOPS_USER
    echo_info_variable PING_IDENTITY_DEVOPS_KEY
    echo
    echo_info_variable PING_IDENTITY_DEVOPS_HOME
    echo_info_variable PING_IDENTITY_DEVOPS_REGISTRY
    echo
    echo_info_variable PING_IDENTITY_DEVOPS_TAG
    echo
    echo_info_variable PING_IDENTITY_ACCEPT_EULA
    echo
    echo_info_variable VAULT_ADDR
    echo_info_variable VAULT_CACERT
    echo_info_variable VAULT_SECRET_PREFIX


_listOfCustom_Variables=$(get_custom_variables)

if test ! -z "$_listOfCustom_Variables"; then
  echo "
################################################################################
#     Custom Variables
################################################################################
"

  for _custVar in $_listOfCustom_Variables
  do
      echo_info_variable "${_custVar}"
  done
fi

echo "
################################################################################
 To change config, run:
    ${PI_CMD} config
"
}

print_update_information()
{
  echo "
to update, you can use:
  macosx : brew upgrade pi
  linux  : curl -L https://bit.ly/pi-install | bash"
}

################################################################################
# pi_version ()
#
# Prints tool version info
################################################################################
pi_version()
{
    # Looks for the URL and pulls out the version.  Example should be:
    #
    #      url "https://github.com/pingidentity/pi/archive/v0.5.0.tar.gz"
    #
    _latest_tool_version=$(${CURL} https://bit.ly/pi-version \
      |  grep -e '^  url ".*"$' \
      |  sed "s/.*archive\/v\(.*\)\.tar.*/\1/")

    _curl_result=$?

    test ${_curl_result} -ne 0 || test -z "${_latest_tool_version}" && _latest_tool_version="UNKNOWN"

    if test "${_latest_tool_version}" = "${VERSION}" ||
       test "${_latest_tool_version}" = "UNKNOWN"; then
        _version_msg="${GREEN}${VERSION}${NORMAL} (no update required)"
    else
        _version_msg="${RED}${VERSION}${NORMAL} (updated version ${_latest_tool_version} is available)\n$(print_update_information)"
    fi

    echo "${PI_CMD} version ${_version_msg}"
}

################################################################################
# pi_clean ()
#
# Cleans the ~/.pingidentity/${PI_CMD}
################################################################################
pi_clean()
{

    echo
    echo_red "IMPORTANT: This is destructive of all content ~/.pingidentity/${PI_CMD}"
    echo
    echo "Are you SURE you want to clean/remove this content (y/n) [n] ? \c"
    read -r answer

    if [ "${answer}" != "Y" ] && [ "${answer}" != "y" ]; then
        echo_error "Clean Aborted!"
        exit
    fi

    rm -rf "${PI_WORK_DIR}"
}

################################################################################
# vault_get_token ()
#
# Hashicorp Vault get-token
################################################################################
vault_get_token()
{
    printf "Getting vault token..."

    # _vaultCACRT="${TMP_DIR}/vault.ca.crt"
    # kubectl get secrets vault-tls-secret -o jsonpath="{.data.vault\.crt}"|base64 --decode > "${_vaultCACRT}"

    if test -n "${VAULT_CACERT}" && test -s "${VAULT_CACERT}" ; then
      _vaultCACRT="${VAULT_CACERT}"
    fi

    kubectl get serviceaccount vault-auth 2>/dev/null >/dev/null
    test $? -ne 0 && echo "Creating 'vauth-auth' serviceaccount" && kubectl create serviceaccount vault-auth

    _k8sToken=$(kubectl get secrets -o jsonpath="{.items[?(@.metadata.annotations['kubernetes\.io/service-account\.name']=='vault-auth')].data.token}"|base64 --decode)


    _vaultToken=$(${CURL} --request POST "${VAULT_ADDR}/v1/auth/kubernetes/login" \
      $( test -s "${_vaultCACRT}" && echo "--cacert ${_vaultCACRT}" ) \
      --header 'Content-Type: application/json' \
      --data-raw "{\"jwt\":\"${_k8sToken}\",\"role\":\"k8s-default\"}" \
      --fail 2>/dev/null | jq -r .auth.client_token)
    _curl_result=$?

    printf "\n\n"
    vault login --address=${VAULT_ADDR} -format=table "${_vaultToken}"
}

################################################################################
# vault_create_annotation ()
#
# Hashicorp Vault create_annotation
################################################################################
vault_create_annotation()
{
    local readonly secret="${1}"

    vault kv get -format=json ${secret}  | jq '.data.data'> ${TMP_DIR}/vault.sec

    _secretName=$(basename "${secret}")

    case "${_secretName}" in
        *.env)
            cat >> "${TMP_DIR}/k8s.annotations" <<EOANNOTATION1
    #
    #------------ env: ${_secretName}
    vault.hashicorp.com/agent-inject-secret-${_secretName}: "${secret}"
    vault.hashicorp.com/agent-inject-template-${_secretName}: |
      {{ with secret "${secret}" -}}
EOANNOTATION1
            for _secretKey in $(jq -r 'keys | .[]' ${TMP_DIR}/vault.sec); do
                echo "      export ${_secretKey}=\"{{ .Data.data.${_secretKey} }}\"" >> "${TMP_DIR}/k8s.annotations"
            done

            cat >> "${TMP_DIR}/k8s.annotations" <<EOANNOTATION2
      {{- end }}
    #------------------------------------------------
EOANNOTATION2
            ;;
        *)
            for _secretKey in $(jq -r 'keys | .[]' ${TMP_DIR}/vault.sec); do
                cat >> "${TMP_DIR}/k8s.annotations" <<EOANNOTATION3
    #
    #------------ key: ${_secretKey}
    vault.hashicorp.com/agent-inject-secret-${_secretKey}: "${secret}"
    vault.hashicorp.com/agent-inject-template-${_secretKey}: |
      {{ with secret "${secret}" -}}
      {{ .Data.data.${_secretKey} }}
      {{- end }}
    #------------------------------------------------
EOANNOTATION3
            done
            ;;
    esac
}

################################################################################
# vault_create_annotations ()
#
# Hashicorp Vault create_annotations
################################################################################
vault_create_annotations()
{
  local readonly secretPath="${1}"

  local readonly vresult=$( vault kv list -format=json ${secretPath})

  if test -z "${vresult}" || test $? -ne 1; then
    echo ""
    echo_red "Error: Unable to make a call to vault.  Possibly your token has timed out."
    echo_red "       Get a new token and re-run."
    echo ""
    echo "  ${PI_CMD} vault get-token"
    return
  fi

  if test "${vresult}" = "{}" ; then
    vault_create_annotation "${secretPath}"
    return
  fi

  local readonly _firstRow=true
  for secret in $(echo "${vresult}" | jq -r '.[]'); do
    test "$_firstRow" = true \
      && _firstRow=false \
      && printf "    #\n    #-------- secret: %s\n" "${secretPath}" >> "${TMP_DIR}/k8s.annotations"

    vault_create_annotations "${secretPath}${secret}"
  done
}

################################################################################
VAULT_ANNOTAION_PREAMBLE="
  annotations:
    #----------------------------------------------------
    # Annotation secretes prepared for hashicorp vault secrets
    # for use in Deployment, StatefulSet, Pod resources.
    #
    # https://www.vaultproject.io/docs/platform/k8s/injector/annotations
    #
    vault.hashicorp.com/agent-pre-populate-only: \"true\"
    vault.hashicorp.com/agent-inject: \"true\"
    vault.hashicorp.com/role: \"k8s-default\"
    vault.hashicorp.com/log-level: \"info\"
    vault.hashicorp.com/preserve-secret-case: \"true\"
    vault.hashicorp.com/secret-volume-path: \"/run/secrets\"
    #----------------------------------------------------"

################################################################################
# pi_vault ()
#
# Hashicorp Vault CLI
################################################################################
pi_vault()
{
    _vault_cmd="${1}" && shift

    _remainParams="${*}"

    check_config_file
    #check_for_tool $VAULT
    check_variables VAULT_ADDR

    case "${_vault_cmd}" in
        get-token)
            vault_get_token
            ;;
        create-annotations)
            _secretPath="secret/${VAULT_SECRET_PREFIX}/${_remainParams}$(test -n "${_remainParams}" && printf "/")"

            vault_create_annotations "${_secretPath}"

            if test -s "${TMP_DIR}/k8s.annotations" ; then
                echo "${VAULT_ANNOTAION_PREAMBLE}"
                cat "${TMP_DIR}/k8s.annotations"
            fi
            ;;
        *)
            usage_command USAGE_VAULT "unknown/missing vault command: ${_vault_cmd}"
            ;;
    esac
}


################################################################################
# kubernetes_command
################################################################################
kubernetes_command()
{
  _k8s_cmd="${1}" && shift $(( $# > 0 ? 1 : 0 ))

  case "${_k8s_cmd}" in
      oidc)     oidc_tools "${@}" ;;
      generate) generate_resource "${@}" ;;
      *)        usage_command USAGE_KUBERNETES_DETAIL  "unknown/missing kubernetes command: ${_k8s_cmd}";;
  esac

}

################################################################################
# oidc_tools
################################################################################
oidc_tools()
{
    _oidc_opt="${1}"

    if test ! -d "${KUBE_OIDC_CACHE}"; then
        echo "--no-token--"
        exit
    fi

    case "${_oidc_opt}" in
        clear)
            echo "Removing ${KUBE_OIDC_CACHE}"
            rm -rf "${KUBE_OIDC_CACHE}"
            ;;
        info)
            check_for_tool $JWT
            jq -r .id_token "${KUBE_OIDC_CACHE}"/*  | $JWT decode -
            ;;
        *)
            check_for_tool $JWT
            jq -r .id_token "${KUBE_OIDC_CACHE}"/*  | jwt decode - -j | jq -r ".payload.${_oidc_opt}"
            ;;
    esac
}

################################################################################
# generate_resource
################################################################################
generate_resource()
{
    _secret="${1}"

    case "${_secret}" in
        devops-secret)
            check_variables \
                PING_IDENTITY_DEVOPS_USER \
                PING_IDENTITY_DEVOPS_KEY \
                PING_IDENTITY_ACCEPT_EULA

            check_for_tool $BASE64

            echo "
apiVersion: v1
kind: Secret
metadata:
  name: devops-secret
  annotations:
    ${PI_CMD}.user: ${PING_IDENTITY_DEVOPS_USER}
    ${PI_CMD}.app-version: v${VERSION}
type: Opaque
data:
  PING_IDENTITY_DEVOPS_USER: $(base64_no_newlines "${PING_IDENTITY_DEVOPS_USER}")
  PING_IDENTITY_DEVOPS_KEY: $(base64_no_newlines "${PING_IDENTITY_DEVOPS_KEY}")
  PING_IDENTITY_ACCEPT_EULA: $(base64_no_newlines "${PING_IDENTITY_ACCEPT_EULA}")
"
            ;;

        tls-secret)
            _domain="${2}"
            test -z "${_domain}" && usage "Missing tls-secret domain"

            check_for_tool $OPENSSL
            check_for_tool $BASE64

            test ! -f /etc/ssl/openssl.cnf && echo_error "Missing /etc/ssl/openssl.cnf" && exit

            _opensslcnf="${TMP_DIR}/openssl.cnf"
            _tlsKey="${TMP_DIR}/tls.key"
            _tlsCrt="${TMP_DIR}/tls.crt"

            cat /etc/ssl/openssl.cnf > "${_opensslcnf}"
            printf "[SAN]\nsubjectAltName=DNS:*.%s" "${_domain} " >> "${_opensslcnf}"

            $OPENSSL req -x509 -nodes -newkey rsa:2048 -days 3650 -sha256 \
              -out "${_tlsKey}" -keyout "${_tlsCrt}" \
              -subj "/CN=${_domain}" \
              -reqexts SAN -extensions SAN \
              -config "${_opensslcnf}" > /dev/null 2>&1

            echo "
apiVersion: v1
kind: Secret
type: kubernetes.io/tls
metadata:
  name: tls-secret
  annotations:
    ${PI_CMD}.dns-zone: ${_domain}
    ${PI_CMD}.app-version: v${VERSION}
data:
  tls.crt: $(base64_no_newlines "${_tlsCrt}")
  tls.key: $(base64_no_newlines "${_tlsKey}")"
            ;;
        ssh-id-secret)
            _idKey="${2}"

            echo "
apiVersion: v1
kind: Secret
metadata:
  name: ssh-id-key-secret
data:
  id_rsa: |
    $(base64_no_newlines "${_idKey}")"
            ;;
        license-secret|license)
            generate_license_secret "${1}" "${2}" "${3}"
            ;;
        *)
            usage_command USAGE_GENERATE_DETAIL "unknown/missing generate option: ${_secret}"
            ;;
    esac
}

################################################################################
# generate_license_secret (command, name of product or license file)
#
# Generates a license secret for the passed license file or name of product
#  - license {produtct-name} {product-version}
#  - license-secret {file}
#  - license-secret {product-name} {product-version}
################################################################################
generate_license_secret()
{
  _licenseType="${1}"
  _licenseArg="${2}"
  _licenseVer="${3}"

  case "${_licenseType}" in
      license-secret)
          if test -f "${_licenseArg}"; then
              _licenseFile="${_licenseArg}"
              _licenseSecretName="ping-license"
          else
              _licenseProd="${_licenseArg}"
              _licenseSecretName="${_licenseProd}-license"
          fi
          ;;
      license)
          test -z "${_licenseArg}" && usage "Missing product name (i.e. pingfederate)"
          _licenseProd="${_licenseArg}"
          ;;
      *)
          usage "Unknown generate resource '${_licenseType}"
  esac

  #
  # Getting an evaluation license based on product passed
  if test -n "${_licenseProd}"; then
    case "${_licenseProd}" in
      pingaccess|pingcentral|pingdatametrics|pingdatasync|pingdatagovernance|pingdatagovernancepap|pingdirectory|pingdirectoryproxy|pingfederate|pingintelligence|pingauthorize|pingauthorizepolicyeditor)

        check_for_tool $DOCKER

        check_variables \
            PING_IDENTITY_DEVOPS_USER \
            PING_IDENTITY_DEVOPS_KEY

        test -n "${_licenseVer}" && _downloadVer="--version ${_licenseVer}"

        $DOCKER run --rm -v /tmp:/tmp "${PING_IDENTITY_DEVOPS_REGISTRY}/pingdownloader" \
          --product "${_licenseProd}" ${_downloadVer} \
          --license \
          --devops-user "${PING_IDENTITY_DEVOPS_USER}" \
          --devops-key "${PING_IDENTITY_DEVOPS_KEY}" \
          --devops-app "pingdevops" >/dev/null 2>>/dev/null
        _dockerRunResult=$?

        test $_dockerRunResult -ne 0 && usage "Unable to pull eval license (result=$_dockerRunResult)\nCheck that you can run 'docker version'\nCheck that your PING_IDENTITY_DEVOPS_USER and PING_IDENTITY_DEVOPS_USER are valid.\nCheck your product version is valid, if you provided one."

        _licenseFile="/tmp/product.lic"

        ;;
      *)
        usage "Invalid product name '${_licenseProd}'"
        ;;
    esac
  fi

  case "${_licenseType}" in
      license-secret)
              _licenseSecret=$(base64_no_newlines "${_licenseFile}")

              echo "
apiVersion: v1
kind: Secret
metadata:
  name: ${_licenseSecretName}
  labels:
    pingidentity.com/generated-by: ${PI_CMD}
data:
  license: |
    ${_licenseSecret}"
          ;;
      license)
          cat /tmp/product.lic
          ;;
  esac

}

################################################################################
################################################################################
pi_config()
{

    ################################################################################
    # Get all the custom variables from the devops file before we backup
    ################################################################################
    _custom_variables=$(get_custom_variables)

    ################################################################################
    # Check for existance of the devops file and backup to .prev
    ################################################################################
    if test -f "${CONFIG_FILE}"; then
        mv "${CONFIG_FILE}" "${CONFIG_FILE}".prev

        # If the config is broken (i.e. ctrl-c) then restore the previous file
        trap '
            echo
            echo "restoring: ${CONFIG_FILE}"
            mv "${CONFIG_FILE}".prev "${CONFIG_FILE}"
            exit
        ' HUP INT PIPE TERM
    fi

    echo "

################################################################################
#
#                     Welcome to Ping Identity Command Line Tool!
#
#  We will run through a few config items to make your experiance as easy as
#  possible.  These include:
#
#    - Setting up your default '${PRINT_CONFIG_FILE}' settings
#    - Adding bash_profile.${PI_CMD} to your .bash_profile, if neeeded
#"

    print_variable_setting_instructions

    echo "################################################################################
# Variables used to assist pingone operations
################################################################################
" | tee -a "${CONFIG_FILE}"


    add_config "${CONFIG_FILE}" "PINGONE_ENVIRONMENT_ID"                 "" "PingOne Environment ID"
    add_config "${CONFIG_FILE}" "PINGONE_WORKER_APP_CLIENT_ID"           "" "PingOne Worker App Client ID"
    add_config "${CONFIG_FILE}" "PINGONE_WORKER_APP_CLIENT_SECRET"       "" "PingOne Worker App Client Secret"

echo "################################################################################
# Variables used to assist devops operations
################################################################################
" | tee -a "${CONFIG_FILE}"

    add_config "${CONFIG_FILE}" "PING_IDENTITY_ACCEPT_EULA"               "NO" "Do you accept the terms of license (found here: https://www.pingidentity.com/en/legal/subscription-agreement.html) with Ping Identity? (YES/NO)"
    add_config "${CONFIG_FILE}" "PING_IDENTITY_DEVOPS_USER"               ""                        "Ping Identity DevOps User (request here: https://bit.ly/ping-devops-request)"
    add_config "${CONFIG_FILE}" "PING_IDENTITY_DEVOPS_KEY"                ""                        "Ping Identity DevOps Key"
    add_config "${CONFIG_FILE}" "PING_IDENTITY_DEVOPS_HOME"               "${HOME}/projects/devops" "Location of Ping Identity DevOps repos and tools"
    add_config "${CONFIG_FILE}" "PING_IDENTITY_DEVOPS_REGISTRY"           "docker.io/pingidentity"  "Ping Identity DevOps Registry (recommend default: docker.io/pingidentity)"
    add_config "${CONFIG_FILE}" "PING_IDENTITY_DEVOPS_TAG"                "edge"                    "Ping Identity DevOps Tag (recommend default: edge)"

    echo "
################################################################################
# Hashicorp Vault - If your kubernetes cluster is setup to use a vault from
#                   Hashicorp, you may optionally provide a URL to that vault
################################################################################
" | tee -a "${CONFIG_FILE}"

    add_config "${CONFIG_FILE}" "VAULT_ADDR"                              "https://vault.example.com:8200"  "Hashicorp Vault Address"
    add_config "${CONFIG_FILE}" "VAULT_CACERT"                            ""                                "File Location of Vault CA Cert (i.e. ~/.vault-ca-cert)"
    add_config "${CONFIG_FILE}" "VAULT_SECRET_PREFIX"                     "${PING_IDENTITY_DEVOPS_USER}/${CURRENT_K8S_NAMESPACE}"  "Vault Secret Prefix"

    echo "
################################################################################
#              Ping Identity Customized Variables
################################################################################
# Additional variables that you would like to send to containers via
# docker-compose.yaml and kubernetes .yaml files.
#
# Examples include:
#     PING_CONTAINER_PRIVILEGED=false
#     PING_CONTAINER_UID=12345
#     PING_CONTAINER_GID=9876
#     LDAP_PORT=1389
#     LDAPS_PORT=1636
#     HTTPS_PORT=1443
#     JMX_PORT=1689
#     PING_IDENTITY_PASSWORD=2FederateM0re
#
# These are often set to nothing, unless you are using advanced features
################################################################################
" | tee -a "${CONFIG_FILE}"

    add_config_custom "${CONFIG_FILE}" "${_custom_variables}"

    add_bash_aliases

    echo "

################################################################################
#
# To get these changes effective in your current shell, you should either:
#
#    o Restart your Terminal Session (will source your ~/.bash_profile)
#    o Source your ~/.bash_profile
#
################################################################################
    "
}

########################################################################################################################
# base64-encode the provided string or file contents and remove any new lines (both line feeds and carriage returns).
#
# Arguments
#   ${1} -> The string to base-64 encode, or a file whose contents to base64-encode.
########################################################################################################################
base64_no_newlines()
{
  if test -f "${1}"; then
    # shellcheck disable=SC2002
    cat "${1}" | $BASE64 | tr -d '\r?\n'
  else
    printf "${1}" | $BASE64 | tr -d '\r?\n'
  fi
}


################################################################################
# getPingOneAccessToken
################################################################################
getPingOneAccessToken ()
{
    check_variables \
        PINGONE_ENVIRONMENT_ID \
        PINGONE_WORKER_APP_CLIENT_ID \
        PINGONE_WORKER_APP_CLIENT_SECRET

    _auth_response=$( $CURL --request POST "https://auth.pingone.com/${PINGONE_ENVIRONMENT_ID}/as/token" \
                    --header 'Content-Type: application/x-www-form-urlencoded' \
                    --user "${PINGONE_WORKER_APP_CLIENT_ID}:${PINGONE_WORKER_APP_CLIENT_SECRET}" \
                    --data-urlencode 'grant_type=client_credentials' )

    PINGONE_ACCESS_TOKEN=$(jq --raw-output '.access_token'  <<<"${_auth_response}")
}




###############################################################################
# cat_indent (file)
#
# cat a file to stdout and indent 4 spaces
###############################################################################
cat_indent ()
{
    test -f "${1}" && sed 's/^/    /' < "${1}"
}

################################################################################
# print_json_field
################################################################################
print_json_field()
{
  _json_data="${1}" && shift
  _jq_fields=""
  _comma=""

  # error_pingone_call 200

  while true
  do
    _label="${1}" && shift
    test -z "${_label}" && break
    _field="${1}" && shift
    _jq_fields="${_jq_fields}${_comma}\"${_label}\", ${_field}, \"\\n\""
    _comma=","
  done

  jq -jr "${_json_data} |
    ${_jq_fields}" <"${PINGONE_CALL_RESPONSE}"
}

################################################################################
# print_json_fields
################################################################################
print_json_fields()
{
  _print_format="${OPT_PINGONE_o:-field}"
  case "${_print_format}" in
    csv|field|table) print_json_field "${@}" ;;
    json) print_json_json "${@}" ;;
    *) usage_command ;;
  esac


}


################################################################################
# print_json
################################################################################
print_json()
{
  _print_format="${OPT_PINGONE_o:-table}"
  case "${_print_format}" in
    table) print_json_sv "tsv" "${@}" ;;
    csv) print_json_sv "csv" "${@}" ;;
    json) print_json_json "${@}" ;;
    *) usage_command ;;
  esac
}

################################################################################
# print_json_sv
################################################################################
print_json_sv()
{
  _sv="${1}" && shift
  _json_data="${1}" && shift
  _sort_column="${1}" && shift
  _tableColumns=""
  _comma=""

  while true
  do
    _column="${1}" && shift
    test -z "${_column}" && break
    _tableColumns="${_tableColumns}${_comma}${_column}"
    _comma=","
  done

  cat "${PINGONE_CALL_RESPONSE}" | jq -r "
    ${_json_data}
    | [sort_by(${_sort_column}) | .[]
    |
        {
            ${_tableColumns}
        }
    ]
    # lowercase keys |  [.[] | with_entries( .key |= ascii_downcase ] )
    |  [.[] ]
    # (for predictable sorting, optional)
    |    (.[0] |keys_unsorted | @${_sv})               # print headers
        , (.[]|.|map(.) |@${_sv})                       # print table
    " | column -t -s "$(printf '\t')"
}

################################################################################
# print_json_csv
################################################################################
print_json_csv()
{
  _json_data="${1}" && shift
  _sort_column="${1}" && shift
  _tableColumns=""
  _comma=""

  while true
  do
    _column="${1}" && shift
    test -z "${_column}" && break
    _tableColumns="${_tableColumns}${_comma}${_column}"
    _comma=","
  done

  cat "${PINGONE_CALL_RESPONSE}" | jq -r "
    ${_json_data}
    | [sort_by(${_sort_column}) | .[]
    |
        {
            ${_tableColumns}
        }
    ]
                        # lowercase keys
                        # (for predictable sorting, optional)
    |  [.[]| with_entries( .key |= ascii_downcase ) ]
    |    (.[0] |keys_unsorted | @csv)               # print headers
        , (.[]|.|map(.) |@csv)                       # print table
    "
}

################################################################################
# print_json_json
################################################################################
print_json_json()
{
  jq . < "${PINGONE_CALL_RESPONSE}"
}

################################################################################
# pingone_get_call
################################################################################
pingone_get_call()
{
  _url_end="${1}" && shift
  _filter="${1}"

  if test "${OPT_PINGONE_r}" == "true"; then
    echo "REST Call: curl -L https://api.pingone.com/v1/environments/${PINGONE_ENVIRONMENT_ID}/${_url_end}?${_filter}
--------------------------------------" >> "${PINGONE_DEBUG}"
  fi

  PINGONE_CALL_RESULT=$($CURL -G --request GET "https://api.pingone.com/v1/environments/${PINGONE_ENVIRONMENT_ID}/${_url_end}" \
      --data-urlencode "${_filter}" \
      --header 'Content-Type: application/json' \
      --header "Authorization: Bearer ${PINGONE_ACCESS_TOKEN}" \
      --write-out '%{http_code}' \
      --output "${PINGONE_CALL_RESPONSE}")

  error_pingone_call 200
}

################################################################################
# error_pingone_call
################################################################################
error_pingone_call()
{
  _expected_result="${1}"

  test ${PINGONE_CALL_RESULT} == "${_expected_result}" && return

  _err_message=$(jq -r .details[].message <${PINGONE_CALL_RESPONSE})

  echo "ERROR: ${_err_message}"


  _err_message=$(jq -r .message <${PINGONE_CALL_RESPONSE})

  echo "ERROR: ${_err_message}"

  exit
}

################################################################################
# pingone_post_call
################################################################################
pingone_post_call()
{
  _url_end="${1}"

  if test "${OPT_PINGONE_r}" == "true"; then
    echo "REST Call: curl -L --request POST https://api.pingone.com/v1/environments/${PINGONE_ENVIRONMENT_ID}/${_url_end}" >> "${PINGONE_DEBUG}"
    cat_indent "${PINGONE_POST_JSON}" >>  "${PINGONE_DEBUG}"
    echo "--------------------------------------" >> "${PINGONE_DEBUG}"
  fi

  PINGONE_CALL_RESULT=$($CURL --request POST \
    -g "https://api.pingone.com/v1/environments/${PINGONE_ENVIRONMENT_ID}/${_url_end}" \
    --data-binary @"${PINGONE_POST_JSON}" \
    --header 'Content-Type: application/json' \
    --header "Authorization: Bearer ${PINGONE_ACCESS_TOKEN}" \
    --write-out '%{http_code}' \
    --output "${PINGONE_CALL_RESPONSE}")

  error_pingone_call 201
}

################################################################################
# pingone_delete_call
################################################################################
pingone_delete_call()
{
  _url_end="${1}"

  if test "${OPT_PINGONE_r}" == "true"; then
    echo "REST Call: curl -L --request DELETE https://api.pingone.com/v1/environments/${PINGONE_ENVIRONMENT_ID}/${_url_end}
--------------------------------------" >> "${PINGONE_DEBUG}"
  fi

  PINGONE_CALL_RESULT=$($CURL --request DELETE \
    -g "https://api.pingone.com/v1/environments/${PINGONE_ENVIRONMENT_ID}/${_url_end}" \
    --header 'Content-Type: application/json' \
    --header "Authorization: Bearer ${PINGONE_ACCESS_TOKEN}" \
    --write-out '%{http_code}' \
    --output "${PINGONE_CALL_RESPONSE}")
  error_pingone_call 204
}

################################################################################
# pingone_list
################################################################################
pingone_list()
{
  USAGE_CONTEXT="USAGE_PINGONE_LIST_DETAIL"

  _resource="${1}" && shift $(( $# > 0 ? 1 : 0 ))
  test -z "${_resource}" && usage_command

  get_pingone_options "${@}"
  # Remove the switches we parsed above.
  shift "$(( OPTIND - 1 ))"

  case "${_resource}" in
      users)
            pingone_get_call "users" ""

            print_json "._embedded.users" \
              ".username" \
              "USERNAME:.username" \
              "FIRST:.name.given" \
              "LAST:.name.family" \
              "EMAIL:.email" \
              "POPULATION:.population.id" \
          ;;
      groups)
            pingone_get_call "groups" ""

            print_json "._embedded.groups" \
              ".name" \
              "NAME:.name" \
              "MEMBERS:.directMemberCounts.users"
          ;;
      populations)
            pingone_get_call "populations" ""

            print_json "._embedded.populations" \
              ".name" \
              "NAME:.name" \
              "MEMBERS:.userCount"
          ;;
      *)
          usage_command
          ;;
  esac
}

################################################################################
# pingone_get
################################################################################
pingone_get ()
{
  USAGE_CONTEXT="USAGE_PINGONE_GET_DETAIL"
  _resource="${1}" && shift
  _get_id="${1}" && shift
  test -z "${_resource}" && usage_command
  test -z "${_get_id}" && usage_command

  get_pingone_options "${@}"
  # Remove the switches we parsed above.
  shift "$(( OPTIND - 1 ))"

  case "${_resource}" in
      user)
          pingone_get_call "users" "filter=username eq \"${_get_id}\""

          _user_id=$(jq -r ._embedded.users[].id <"${PINGONE_CALL_RESPONSE}")
          test -z "${_user_id}" && echo "User not found '${_get_id}'" && exit

          print_json_fields "._embedded.users[]" \
            "USERNAME: " ".username" \
            "   FIRST: " ".name.given" \
            "    LAST: " ".name.family"\
            "   EMAIL: " ".email"

          _user_id=$(jq -r ._embedded.users[].id <"${PINGONE_CALL_RESPONSE}")

          pingone_get_call "users/${_user_id}/memberOfGroups" ""

          echo ""
          print_json "._embedded.groupMemberships" \
            ".name" \
            "GROUPS:.name"
          ;;
      group)
          pingone_get_call "groups" "filter=name eq \"${_get_id}\""

          print_json_fields "._embedded.groups[]" \
            "  GROUP NAME: " ".name" \
            "MEMBER COUNT: " ".directMemberCounts.users"

          _group_id=$(jq -r ._embedded.groups[].id <"${PINGONE_CALL_RESPONSE}")

          pingone_get_call "users" "filter=memberOfGroups[id eq \"${_group_id}\"]"

          echo ""
          print_json "._embedded.users" \
            ".username" \
            "USERS:.username" \
            "FIRST:.name.given" \
            "LAST:.name.family" \
            "EMAIL:.email"

          ;;
      population)
          pingone_get_call "populations" "filter=name eq \"${_get_id}\""

          print_json_fields "._embedded.populations[]" \
            "  POPULATION: " ".name" \
            "MEMBER COUNT: " ".userCount"

          _population_id=$(jq -r ._embedded.populations[].id <"${PINGONE_CALL_RESPONSE}")

          pingone_get_call "users" "filter=population.id eq \"${_population_id}\""

          echo ""
          print_json "._embedded.users" \
            ".username" \
            "USERS:.username" \
            "FIRST:.name.given" \
            "LAST:.name.family" \
            "EMAIL:.email"
          ;;
      *)
          usage_command
          ;;
  esac
}

################################################################################
# pingone_get_population_id
################################################################################
pingone_get_population_id()
{
  _name="${1}"
  test -z "${_name}" && usage_command USAGE_PINGONE_GET_DETAIL

  pingone_get_call "populations" "filter=name eq \"${_name}\""
  jq -r ._embedded.populations[].id <"${PINGONE_CALL_RESPONSE}"
}

################################################################################
# pingone_add
################################################################################
pingone_add()
{
  USAGE_CONTEXT="USAGE_PINGONE_ADD_DETAIL"
  _resource="${1}" && shift $(( $# > 0 ? 1 : 0 ))
  test -z "${_resource}" && usage_command

  case "${_resource}" in
      user)
          _username="${1}" && shift
          _first_name="${1}" && shift
          _last_name="${1}" && shift
          _email="${1}"

          if test -z "${_email}" || test ! "${_email}" = "${_email#-}"; then
            _email="${_username}"
          else
            shift
          fi

          get_pingone_options "${@}"
          # Remove the switches we parsed above.
          shift "$(( OPTIND - 1 ))"

          test -z "${_username}" && usage_command
          test -z "${_first_name}" && usage_command
          test -z "${_last_name}" && usage_command

          _population="${OPT_PINGONE_p:-Default}"

          _population_id="$(pingone_get_population_id "${_population}")"
          test -z "${_population_id}" && echo "population not found '${_population}'" && exit

          jq -n '{email: $email,
                  name: {given: $first,
                         family: $last},
                  population: {id: $populationId},
                  username: $username}' \
              --arg populationId "${_population_id}" \
              --arg username "${_username}" \
              --arg email "${_email}" \
              --arg first "${_first_name}" \
              --arg last "${_last_name}" > "${PINGONE_POST_JSON}"

          pingone_post_call "users"
          # error_pingone_call 201
          ;;
      group)
          _name="${1}" && shift

          get_pingone_options "${@}"
          # Remove the switches we parsed above.
          shift "$(( OPTIND - 1 ))"

          test -z "${_population}" && usage_command
          test -z "${_name}" && usage_command

          _population_id="$(pingone_get_population_id "${_population}")"
          test -z "${_population_id}" && echo "population not found '${_population}'" && exit

          jq -n '{name: $name,
                  population: {id: $populationId}
                 }' \
              --arg name "${_name}"  \
              --arg populationId "${_population_id}" > "${PINGONE_POST_JSON}"

          pingone_post_call "groups"
          # error_pingone_call 201
          ;;
      population)
          _name="${1}" && shift

          get_pingone_options "${@}"
          # Remove the switches we parsed above.
          shift "$(( OPTIND - 1 ))"

          test -z "${_name}" && usage_command

          jq -n '{name: $name}' \
              --arg name "${_name}" > "${PINGONE_POST_JSON}"

          pingone_post_call "populations"
          # error_pingone_call 201
          ;;
      *)
          usage_command
          ;;
  esac
}

################################################################################
# pingone_add_user_group
################################################################################
pingone_add_user_group()
{
  _username="${1}" && shift
  _groupname="${1}" && shift

  get_pingone_options "${@}"
  # Remove the switches we parsed above.
  shift "$(( OPTIND - 1 ))"

  test -z "${_username}" && usage_command USAGE_PINGONE_ADD_USER_GROUP_DETAIL
  test -z "${_groupname}" && usage_command USAGE_PINGONE_ADD_USER_GROUP_DETAIL

  get_pingone_options "${@}"
  # Remove the switches we parsed above.
  shift "$(( OPTIND - 1 ))"

  pingone_get_call "users" "filter=username eq \"${_username}\""
  # error_pingone_call 200
  _user_id=$(jq -r ._embedded.users[].id <"${PINGONE_CALL_RESPONSE}")

  pingone_get_call "groups" "filter=name eq \"${_groupname}\""
  # error_pingone_call 200
  _group_id=$(jq -r ._embedded.groups[].id <"${PINGONE_CALL_RESPONSE}")

  jq -n '{id: $groupId}' \
    --arg groupId "${_group_id}" > "${PINGONE_POST_JSON}"

  pingone_post_call "users/${_user_id}/memberOfGroups"

  # error_pingone_call 201
}

################################################################################
# pingone_delete_user_group
################################################################################
pingone_delete_user_group()
{
  _username="${1}" && shift
  _groupname="${1}" && shift

  get_pingone_options "${@}"
  # Remove the switches we parsed above.
  shift "$(( OPTIND - 1 ))"

  test -z "${_username}" && usage_command USAGE_PINGONE_DELETE_USER_GROUP_DETAIL
  test -z "${_groupname}" && usage_command USAGE_PINGONE_DELETE_USER_GROUP_DETAIL

  get_pingone_options "${@}"
  # Remove the switches we parsed above.
  shift "$(( OPTIND - 1 ))"

  pingone_get_call "users" "filter=username eq \"${_username}\""
  # error_pingone_call 200
  _user_id=$(jq -r ._embedded.users[].id <"${PINGONE_CALL_RESPONSE}")

  pingone_get_call "groups" "filter=name eq \"${_groupname}\""
  # error_pingone_call 200
  _group_id=$(jq -r ._embedded.groups[].id <"${PINGONE_CALL_RESPONSE}")

  pingone_delete_call "users/${_user_id}/memberOfGroups/${_group_id}"

  # error_pingone_call 204
}

################################################################################
# pingone_jwt_token
################################################################################
print_jwt_token()
{
  _token="${1}"

  get_pingone_options "${@}"
  # Remove the switches we parsed above.
  shift "$(( OPTIND - 1 ))"

  echo "
RAW Token
---------
${_token}"

  ${JWT} --version 2>/dev/null >/dev/null

  if test ${?} -eq 0; then
    echo "${_token}" | jwt decode -
  else
    echo "
Token details (header/claims) not available - Install jwt-cli tool for more info: brew tap mike-engel/jwt-cli; brew install jwt-cli"
  fi
}


################################################################################
# pingone_token
################################################################################
pingone_token()
{
  print_jwt_token "${PINGONE_ACCESS_TOKEN}"
}

################################################################################
# pingone_delete
################################################################################
pingone_delete()
{
  USAGE_CONTEXT="USAGE_PINGONE_DELETE_DETAIL"
  _resource="${1}" && shift
  _obj_id="${1}" && shift

  get_pingone_options "${@}"
  # Remove the switches we parsed above.
  shift "$(( OPTIND - 1 ))"

  test -z "${_resource}" && usage_command
  test -z "${_obj_id}" && usage_command

  case "${_resource}" in
      user)
          pingone_get_call "users" "filter=username eq \"${_obj_id}\""

          _user_id=$(jq -r ._embedded.users[].id <"${PINGONE_CALL_RESPONSE}")

          test -z "${_user_id}" && echo "User not found '${_obj_id}'" && exit

          pingone_delete_call "users/${_user_id}"
          # error_pingone_call 204
          ;;
      group)
          pingone_get_call "groups" "filter=name eq \"${_obj_id}\""

          _group_id=$(jq -r ._embedded.groups[].id <"${PINGONE_CALL_RESPONSE}")

          test -z "${_group_id}" && echo "Group not found '${_name}'" && exit

          pingone_delete_call "groups/${_group_id}"
          # error_pingone_call 204
          ;;
      population)
          pingone_get_call "populations" "filter=name eq \"${_obj_id}\""

          _population_id=$(jq -r ._embedded.populations[].id <"${PINGONE_CALL_RESPONSE}")

          test -z "${_population_id}" && echo "Population not found '${_name}'" && exit

          pingone_delete_call "populations/${_population_id}"
          # error_pingone_call 204
          ;;
      *)
          usage_command
          ;;
  esac
}


###############################################################################
# pingone_command
################################################################################
pingone_command()
{
  _pingone_command="${1}" && shift $(( $# > 0 ? 1 : 0 ))

  getPingOneAccessToken

  case "${_pingone_command}" in
      list)
          pingone_list "${@}"
          ;;
      get)
          pingone_get "${@}"
          ;;
      add)
          pingone_add "${@}"
          ;;
      delete)
          pingone_delete "${@}"
          ;;
      add-user-group)
          pingone_add_user_group "${@}"
          ;;
      delete-user-group)
          pingone_delete_user_group "${@}"
          ;;
      token)
          pingone_token "${@}"
          ;;
      *)
          usage_command USAGE_PINGONE_DETAIL "unknown/missing pingone command: ${_pingone_command}"
          ;;
  esac

  if test -f "${PINGONE_DEBUG}" ; then
    echo
    echo "--------------------------------------"
    echo "REST Calls Made (-r option)"
    echo "--------------------------------------"
    cat "${PINGONE_DEBUG}"
  fi
}


################################################################################
# get_global_options
################################################################################
get_global_options()
{
  while getopts djco: OPT; do
      case "$OPT" in
          c|j)  eval "export OPT_GLOBAL_\${OPT}=true" ;;
          d) set -x ;;
          o) PI_OUTPUT=$OPTARG ;;
          ?)
              # getopts issues an error message
              usage "Unknown Option ${OPT}"
              ;;
      esac
  done
}

################################################################################
# get_pingone_options
################################################################################
get_pingone_options()
{
  while getopts ro:p: OPT; do
      case "$OPT" in
          r) OPT_PINGONE_r=true ;;
          o|p) eval "export OPT_PINGONE_\${OPT}=\"\${OPTARG}\"" ;;
          ?)
              # getopts issues an error message
              usage "Unknown Option ${OPT}"
              ;;
      esac
  done
}

################################################################################
# main
################################################################################

get_global_options "${@}"
# Remove the switches we parsed above.
shift "$(( OPTIND - 1 ))"

_pi_command="${1}" && shift $(( $# > 0 ? 1 : 0 ))

test -z "${_pi_command}" && usage


case "${_pi_command}" in
    info)
        _params="${*}"

        pi_info ${_params}
        ;;
    config)
        pi_config
        ;;
    version)
        _params="${*}"

        pi_version "${_params}"
        ;;
    clean)
        _params="${*}"

        pi_clean "${_params}"
        ;;
    k8s|kubernetes)
        kubernetes_command "${@}"
        ;;
    p1|pingone)
        pingone_command "${@}"
        ;;
    vault)
        _params="${*}"

        pi_vault ${_params}
        ;;
    *)
        usage "unknown/missing ${PI_CMD} command '${_pi_command}'"
        ;;
esac